# Low-Code Principle #1: Model-Driven Development, The Most Important Concept in Low-Code

(original article: https://www.mendix.com/blog/low-code-principle-1-model-driven-development/)

We describe the what and why of model-driven development this way:

> Abstraction, automation, and openness are the keys to transforming ideas into applications that deliver real business value.

Here’s the backstory of how we arrived at this principle:

Mendix was founded to improve collaboration and communication between business domain experts and software developers, as well as to accelerate the process of creating applications, while also enhancing app relevance and quality.

The biggest impediment to collaboration and communication was, and is, that business and IT simply don’t speak the same language. The traditional waterfall development process accentuates rather than solves this disconnect. The business expert describes in their language what the business needs (in the reqs process). The development team hears through the filters of software languages and IT architecture — because their brains go fast and are always looking at the next step — and so only hears part of what the business expert is describing. Then, they don’t speak much at all until the solution is delivered, months or even years later, and of course, it misses the mark.

It’s safe to say that most developers don’t attend business school. And most business school grads don’t know computer code. They’ve learned different languages, the languages they need to be the best at what they do. (Interesting to note that one of our founders, Roald Kruit, a genius when it comes to software, went back to school and got an MBA to help him grapple with this problem from both sides.)

Model-driven development bridges this language divide. The model gives everyone a common language. Working with visual building blocks, the domain expert can show the developer what the problem or business need is, and the developer can understand it. The developer, in turn, can show the domain expert what is possible and perhaps some novel ways to solve the problem. Back-and-forth they go, reaching understanding and agreement before proceeding to each next step.

And so, there are far fewer missteps, the process moves much more quickly, and the finished product is highly likely to be spot-on. The golden prize of business value is delivered. It’s a win all around.

## What makes a model?

While model-driven development gives users a graphical or visual interface, it’s what’s underneath the visuals that makes all the difference. (You can have a visual interface that is not low-code, but you can’t have low-code without a visual interface.)

With low-code, the model abstracts away from the code. Instead of complex languages with rigid syntaxes, you have building blocks or “pre-built application components,” each with its own domain-specific language, that handle all the technical aspects of the application — the logic, data model, user interface, security, integrations, etc. These components or “pieces of functionality” are abstracted and presented visually to the users.

Those building blocks are the common language that everyone on the team can understand, from business domain expert to hardcore developer. When they are exploring solutions together, they can literally see what each other is talking about, arrange and rearrange the components, and then, thanks to more magic in the model, quickly try the application out.

That magic is automation, another fundamental aspect of model-driven development. The processes underneath that top layer of drag-and-drop visual development — all of the configuration, testing and QA, integrations, and various housekeeping chores — are all seamlessly automated. (This relieves the pro developer of a number of tedious tasks, and is a primary way that low-code boosts productivity and speeds the development process.)

## Look Ma, no code!

So, the question many ask at this point is: How do you have an application without code? The fact is, there are some low-code platforms that rely on code. Lots of code. 100% code. Because their visual model gets interpreted into code that becomes the application. And with that, of course, comes all the traditional pitfalls, quality, and ops issues of typical code-ful applications.

In true model-driven, low-code applications, the model itself is executable in the runtime; there is no need for code. With no need to write and troubleshoot code, the process is exponentially faster and the quality of the finished application is higher. And in those cases where functionality is needed that is not available in one of the prebuilt components, a professional developer can write code to build their own component that then becomes part of the model (and can be made available to other developers in the community through our app store).

## The Ultimate Realization of BizDevOps

Model-driven low-code, by definition, brings the idea of BizDevOps to life, without even a second thought.

Business experts become integral to the process because of the intuitive, understandable visual modeling tools that eliminate all the mystery of code. They can even go so far as to build applications themselves. (We created a tool, an environment, for them to do just that — Mendix Studio.) With zero knowledge of code, they can drag-and-drop their way to a working application.

The developer team gets a big boost in speed and productivity thanks to the visual model. And through automation, they’re relieved of the mundane and repetitive housekeeping tasks that sap productivity and morale. They don’t have to spend a lot of time making choices about languages, data structures, logic flows, and architectural matters — the model makes the right choices for them.

And from an ops perspective, everything is just better and easier thanks to the automated processes, quality checks, and push-button deployment built into the model.

## One more thing: openness

With technology that changes at the blink of an eye and major new phenomena sweeping over the landscape — IoT, AI, augmented reality, blockchain, edge and ambient computing, and whatever else is coming — the challenge for software is adaptation and integration. Model-driven low-code happens to be the ideal platform to handle future innovation, because it is open and endlessly extensible. Low-code isn’t just a tool for building individual apps. The core model is so abstract that anything and everything can be modeled in it. Model-driven low-code as designed by Mendix is a tool for creating, adapting, and evolving entire landscapes, harnessing all the tools and technologies, new, old, and yet-to-be-imagined, that can be used to advance an enterprise’s digital prowess. The Mendix platform is open at every level and, through our Model API and software SDK, integrates with anything.

## Abstract it all away

Using a model to abstract away from lower-level code empowers everyone on the team — both tech and business professionals — to focus on higher-level concepts and solutions. Automation relieves the burden of mundane and repetitive tasks and reduces human errors, thus enhancing quality and boosting productivity. Openness ensures connectivity to everything everywhere, from legacy systems to newly emerging technologies. The results are more relevant, more powerful applications, built faster by orders of magnitude over traditional code-centric platforms. This is the power of model-driven low-code development.

